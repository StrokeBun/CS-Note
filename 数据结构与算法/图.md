## 图

### 1. 介绍

#### 1.1 概念

图由 **顶点** 和 **边** 组成，按不同特点可分为有向图和无向图，带权图和无权图，树就是一种有向无权图

- 度：顶点所连接的边的数量
- 入度：指向该顶点的边的数量
- 出度：以该顶点为起点的边的数量

#### 1.2 存储方式

##### 1.2.1 邻接矩阵

图一共有 n 个顶点，通过一个 n*n 的矩阵记录顶点之间边的情况，查找速度快，但内存开销大，

 <img src="img/图的邻接矩阵表示.jpg" style="zoom:70%"/>

##### 1.2.2 邻接表

邻接表通过数组 + 链表的形式存储图，内存开销小，但查找速度有所降低

<img src="img/图的邻接表存储.jpg" style="zoom:90%" />

### 2. 拓扑排序

拓扑排序将有向图的顶点排成一个线性序列，主要用于 **组织工作顺序或者判断有先后依赖的工作能否完成**

构造图：如果任务 s 先于 t 执行，则添加一条 s 指向 t 的边。如果顶点入度为 0，则该顶点可以执行

拓扑排序的主要方法有 Kahn 算法和 DFS 算法

#### 2.1 Kahn 算法

Kahn 算法工作流程：寻找一个入度为 0 的顶点，将其添加到拓扑排序结果序列，将该顶点删除。不断重复该过程，即可得到拓扑排序的结果

Kahn 算法的复杂度为 O(V+E)，V 为顶点个数，E 为边的个数

``` java
public void topoSortByKahn() {
  int[] inDegree = new int[v]; // 统计每个顶点的入度
  for (int i = 0; i < v; ++i) {
    for (int j = 0; j < adj[i].size(); ++j) {
      int w = adj[i].get(j); // i->w
      inDegree[w]++;
    }
  }
  LinkedList<Integer> queue = new LinkedList<>();
  for (int i = 0; i < v; ++i) {
    if (inDegree[i] == 0) queue.add(i); // 添加初始节点
  }
  while (!queue.isEmpty()) {
    int i = queue.remove();
    System.out.print("->" + i); // 这里选择将节点输出，实际使用将其加入结果序列
    for (int j = 0; j < adj[i].size(); ++j) {
      int k = adj[i].get(j);
      inDegree[k]--;
      if (inDegree[k] == 0) queue.add(k);
    }
  }
}
```

#### 2.2 DFS

DFS 进行拓扑排序的流程

- 通过邻接表构造逆连接表
- 递归处理每个节点，先添加所有可达节点，再添加本节点

DSF 求解拓扑排序的复杂度为 O(V+E)

``` java
public void topoSortByDFS() {
  // 先构建逆邻接表，边 s->t 表示，s 依赖于 t，t 先于 s
  LinkedList<Integer> inverseAdj[] = new LinkedList[v];
  for (int i = 0; i < v; ++i) {
    inverseAdj[i] = new LinkedList<>();
  }
  for (int i = 0; i < v; ++i) { // 通过邻接表生成逆邻接表
    for (int j = 0; j < adj[i].size(); ++j) {
      int w = adj[i].get(j); // i->w
      inverseAdj[w].add(i); // w->i
    }
  }
  boolean[] visited = new boolean[v];
  for (int i = 0; i < v; ++i) { // 深度优先遍历图
    if (visited[i] == false) {
      visited[i] = true;
      dfs(i, inverseAdj, visited);
    }
  }
}
 
private void dfs(
    int vertex, LinkedList<Integer> inverseAdj[], boolean[] visited) {
  for (int i = 0; i < inverseAdj[vertex].size(); ++i) {
    int w = inverseAdj[vertex].get(i);
    if (visited[w] == true) continue;
    visited[w] = true;
    dfs(w, inverseAdj, visited);
  } // 先把 vertex 这个顶点可达的所有顶点都打印出来之后，再打印它自己
  System.out.print("->" + vertex);
}
```

### 3. 最短路径



