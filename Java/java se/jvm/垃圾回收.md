[toc]

## 垃圾回收

### 1. 对象已死？

#### 1.1 垃圾判断

对于判断哪些对象可被回收，有以下两种方法：

- 引用计数：为对象添加一个计数器，被引用则加一，解除引用则减一；简单高效，但无法解决循环引用的问题
- 可达性分析：jvm 采用的方法，如果对象到 `GCRoot` 之间不存在引用链，则可以被回收；可用于 `GCRoot` 的对象
  - 虚拟机栈引用的对象，例如调用方法堆栈中的参数、局部变量、临时变量
  - 方法区中类静态属性对象
  - 方法区中常量对象，例如字符串常量池对象
  - 本地方法栈中引用的对象
  - jvm 内部引用，例如包装类型 Class 对象、异常对象、系统类加载器
  - 被 synchronized 持有的对象
  - JMX Bean、jvm TI 中注册的回调、本地代码缓存等

#### 1.2 引用类型

- 强引用：普遍使用的类型，只要强引用关系存在，被引用的对象就不会被回收
- 软引用：被引用的对象在 OOM 前进行回收，如果回收后还没有足够内存，则抛出 OOM 异常，常用于实现缓存
- 弱引用：被引用的对象在下一次 GC 被回收，常用于实现缓存
- 虚引用：不影响对象声明周期，用于通知对象已被回收



### 2. 垃圾收集算法

#### 2.1 堆分区

- 新生代：Eden：S0：S1 = 8:1:1
  - Eden
  - Survivor 0
  - Survivor 1
- 老年代

#### 2.2 GC 分类

针对不同区域的垃圾回收，GC 可分为：

- 部分收集
  - Minor GC/Young GC：单独在年轻代 GC
  - Major GC/Old GC：单独在老年代 GC，只有 CMS 收集器单独在老年代 GC
- Full GC：在整个堆和方法区进行 GC

#### 2.3 GC 算法

##### 2.3.1 标记清除算法

流程：标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象。

缺点：

- 效率不稳定，随对象数量增长而降低
- 内存碎片化

##### 2.3.2 标记复制算法

流程：分配两块内存，当一块内存耗尽，将存活的对象复制到另一块内存上，并清除耗尽的内存重新使用。

缺点：可用内存降低，空间浪费

##### 2.3.3 标记-整理算法

流程：标记出所有需要回收的对象，标记完成后，将存活的对象移动到内存的一端，清除其余的对象。

缺点：需要 STW（Stop The World），效率较低



### 3. 垃圾收集器

#### 3.1 经典垃圾收集器

- Serial/Serial Old 收集器：Serial/Serial Old 是新生代/老年代的垃圾收集器，Serial 采用标记复制算法，Serial Old 采用标记整理算法，GC 时需要 stop the world
- ParNew 收集器：使用多线程进行 GC，其余操作与 Serial 相同
- Parallel Scavenge/Parallel Old：注重于吞吐量，分别采用标记复制和标记整理算法

#### 3.2 CMS收集器



#### 3.3 G1收集器



#### 3.4 ZGC收集器



<img src="img/垃圾回收.svg">