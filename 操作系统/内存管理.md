[toc]



## 内存管理

内存管理的主要工作，**负责内存的分配与回收**，进行**地址转换**(逻辑地址转换为物理地址)

### 1. 虚拟内存

#### 1.1 介绍

**目的**：程序大于内存，使用虚拟内存技术将物理**内存扩充**为更大的逻辑内存；对进程之间进行内存隔离，保证**安全性**

**基本思想**：程序拥有自己的地址空间，并划分为 **页**，每一页是连续的，页间不要求连续，这些页被映射到物理内存，当程序引用不在物理内存中的页时，将触发**缺页中断**，通过 MMU 执行映射，将所需的页装入物理内存，重新执行指令

**MMU**：实现虚拟地址到物理地址的映射



#### 1.2 快表与多级页表

**快表 TLB**

快表是为了**加快地址转换的速度**，本质上类似 CPU 中的 cache，使用快表后的地址转换流程：

- 根据虚拟地址的页号查询快表
- 在快表中，则直接读取物理地址
- 不在快表中，则访问页表得到物理地址，并在块表中进行添加
- 快表满了之后按照淘汰策略淘汰一个页



**多级页表**

目的是不把所有页表一直放在内存占用空间，将页表分为多级，当需要时再进行调用查询，只需要在内存中存放上级页表即可 (类似书的标题)



#### 1.3 分段

分段机制：分页机制中的页无实际意义，分段则将内存分为一个个段，各段的长度可以不同，可以动态增长，并给予逻辑意义：主程序段、子程序段、数据段、栈段等等，通过段表进行转换

**段页式管理**：将内存先分成若干段，每个段分成若干页



**分段与分页的比较**

- 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段
- 地址空间的维度：分页是一维地址空间，分段是二维的
- 大小是否可以改变：页的大小不可变，段的大小可以动态改变
- 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护



### 2. 页面置换算法

主要目标：使页面置换次数最少，即缺页率最低

- **最佳置换算法 OPT**：Optimal，选择最长时间不再被访问的页换成，理论算法，无法实现

- **最少使用LFU**：Least Frequently Used，选择在之前时期使用最少的页面作为淘汰页

- **最近最久未使用 LRU**：Last Recently Used，选择最近最久未使用的页面换出，维护一个链表，当页面被访问时将其移到表头，需要置换时将表尾页面换出

- **最近未使用 NRU**：Not Recently Used，设置两个状态位 R 和 M，页面被访问时 R 置为 1，页面被修改时 M 置为 1， R 会定期清 0，优先置换 R = 0，M = 0 和 R = 0， M = 1的页面(随机选择)

- **FIFO**：将最先进入的页面换出

- **第二次机会算法**：对 FIFO 的完善，页面被访问时置 R = 1。需要置换时检查 R，如果 R 为 0 ，表明是未访问的老页面， 进行置换；如果 R 为 1，将 R 清 0，并将该页面当作新页面对待

- **时钟算法 Clock**：将第二次机会算法的链表改为环型链表，并使用一个指针指向最老页面

  

