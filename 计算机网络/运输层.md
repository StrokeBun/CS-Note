[toc]



## 概述

运输层为**进程**之间提供端对端的通信，主要有

- TCP 协议：数据单位是 TCP 数据报
- UDP 协议： 数据单位是用户数据报

常见熟知端口号：

![avatar](常见熟知端口号.jpg)

## UDP 协议

### 1. 主要特点

- **无连接**
- **尽最大努力交付**：即不可靠交付
- **面向报文**：一次交付一个完整的报文
- **无拥塞控制**
- **支持一对一、一对一、多对一、多对多的通信**
- **首部开销小**：首部 8 个字节

### 2. 首部格式

![avatar](UDP首部格式.jpg)

UDP 首部从上图第 2 行开始

- **源端口**
- **目的端口**
- **长度**：范围在 8 - 65535
- **检验和**：添加伪首部后，检验和计算涉及**首部 + 数据部分**



## TCP 协议

### 1. 主要特点

- **面向连接**
- **一对一**
- **可靠交付**
- **全双工通信**
- **面向字节流**

### 2. 首部格式

![avatar](TCP首部格式.jpg)

- **源端口**：2 字节

- **目的端口**：2 字节

- **序号**：4 字节，字节流中的每一个字节都有相应的序号，该字段的值是本报文段数据部分第一个字节的序号

- **确认号**：4字节，期望收到对方**下一个字节**的序号，确认号为 N，则已经正确收到 N - 1 个字节

- **数据偏移**：4位，数据部分在 TCP 报文段的偏移位置，单位是 **32 位字**，故 TCP 首部最大长度为 60 字节

- **保留**：6 位， 目前全为 0

- **6个控制位**：

  **URG**：紧急标志，将优先发送，与紧急指针配合使用

  **ACK**：确认标志，ACK 为 1 报文段才有效

  **PSH**：推送，收到 PSH 为 1 的报文，不等待缓存填满，而是尽快交付

  **RST**：要求重新连接

  **SYN**：同步，用以建立连接时同步序号

  **FIN**：终止，用以释放连接

- **窗口**：2 字节，本报文段**发送方的接收窗口**大小

- **检验和**：2 字节，计算同 UDP

- **紧急指针**：2 字节，指出报文段中紧急数据的字节数



### 3. 可靠传输

**滑动窗口**

发送窗口维护 3 个指针，每次发送 P1 到 P3 的字节流； 接收窗口只对按序收到的最高序号进行确认

![avatar](滑动窗口.jpg)



**超时重传**

![avatar](TCP超时重传.jpg)



### 4. 拥塞控制

发送方维持**拥塞窗口 cwnd**，并使自己的发送窗口大小等于cwnd

4 种控制方法

- **慢开始**：先将 cwnd 设置为一个最大报文段 MSS 的大小，每收到一个新的报文段的确认，cwnd **线性增加一个 MSS 的大小**，设置了**慢开始门限 ssthresh**，当 cwnd > ssthresh 采用拥塞避免算法

- **拥塞避免**：经过一次往返时间 RTT 将 cwnd 增加一个 MSS 的大小，而不是加倍；

  当出现拥塞时，将 ssthresh 设置当前 cwnd 的一半，并置 cwnd 为 1，进行慢开始算法

- **快重传**：接收方收到**失序**的报文段立即发出重复确认，发送方**连续收到三个重复确认**不考虑重传计时器，立即进行重传

- **快恢复**：连续收到三个重复确认后，将 ssthresh 直接减半，设置 cwnd = ssthresh，执行拥塞避免算法

![avatar](TCP拥塞控制流程.jpg)





### 5. 连接建立

TCP 连接的端点是套接字 socket = { IP : Port }

**三次握手**

- B 的 TCP 服务器创建传输控制模块 TCB，处于 LISTEN 状态，等待连接请求

- A 的 TCP 客户进程创建 TCB，发送请求报文，SYN = 1, ACK = 0，选择初始序号 seq = x，

  进入 SYN-SENT (同步已发送)状态

- B 同意连接则发送确认报文，SYN = 1，ACK = 1，ack = x + 1，并选择初始序号 seq = y，

  进入 SYN-RCVD (同步收到)状态

- A 收到 B 的确认，发送确认报文，ACK = 1，ack = y + 1，seq = x + 1，进入 ESTABLISHED (已建立连接) 状态

- B 收到 A 的确认，进入 ESTABLISHED 状态

![avatar](TCP三次握手.jpg)

**<font color=red>为什么需要三次握手?</font>**

有两个原因：

- **确认客户机与服务器的接收与发送功能正常**

  第一次握手：Server 确认了对方发送正常，自己接收正常

  第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常

  第三次握手：确认双方接收与发送正常

- **防止在网络滞留的连接请求报文段到达服务器重新建立连接**

  

### 6. 连接释放

**四次挥手**

- 释放前 A 与 B 都处于 ESTABLISHED状态，A 发送连接释放报文， **FIN = 1**，seq = u，

  进入 FIN-WAIT-1 (终止等待 1)状态

- B 收到报文，发送确认报文，ack = u + 1, B 进入 ClOSE-WAIT (关闭等待)状态，此时 A 到 B 方向 的传输结束， TCP 连接处于 **半关闭**状态

- A 收到来自 B 的确认，进入 FIN-WAIT-2 状态

- B 不再进行发送后，发送释放连接报文，FIN = 1，seq = w，进入 LAST-ACK (最后确认)状态

- A 收到 B 的报文，发送确认报文，ACK = 1，ack = w + 1,  seq = u + 1, 进入 TIME-WAIT (时间等待) 状态，等待 **2MSL** 时间进入 CLOSED 状态； B 收到 A 的确认报文则进入 CLOSED 状态

![avatar](TCP四次挥手.jpg)

**<font color=red>为什么需要四次握手?</font>**

**为了确保双方都结束了数据传送**，因为 TCP 是**全双工**的，任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。类似打电话，一方说完，另一方可以继续说



**TIME-WAIT 状态为什么要等待 2MSL 时间?**

- 确保 B 能够 收到 A 最后的确认报文
- 让本连接持续时间内的报文在网络中消失，使下一个连接不会出现旧的连接请求



**TCP有限状态机**

![avatar](TCP状态机.jpg)