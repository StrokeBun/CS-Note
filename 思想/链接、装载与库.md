## 链接、装载与库

### 1. 静态链接

#### 1.1 编译和链接

编译程序的步骤：

- 预处理：展开宏定义，处理 #if、#ifdef 等条件预编译指令，处理 #include( 将该文件插入到预编译指令的位置)，去除注释，添加行号和文件名标识（编译错误时进行提醒）
- 编译：得到汇编文件
- 汇编：将汇编代码转为机器指令，得到目标文件
- 链接

为什么需要链接，而不是直接生成可执行文件？软件规模大，需要划分多个模块独立编译，链接的作用是 “组装” 这些模块。

重定位：函数调用或者访问其他目标文件的变量时，在编译时无法确定目标地址，故留下 **重定位入口**，链接时对这些地址进行修正

<img src="img/gcc编译过程.jpg"/>

#### 1.2 目标文件

主流目标文件格式：

- PE：Windows 的目标文件
- ELF：Linux 的目标文件

ELF 文件按 **段** 存储，格式如下：

- Header：包括文件属性和段表，文件属性包含版本、程序入口地址等，段表记录各个段的属性和偏移
- .text：编译好的二进制可执行代码
- .data：已初始化的全局变量和静态变量
- .bss：未初始化的全局变量和静态变量
- .rodata：只读数据
- .symtab：符号表，记录函数和变量
- .rel.data：数据段的重定位表，保存需要重定位的信息
- .rel.text：代码段的重定位表

<img src="img/ELF格式.jpg" style="zoom:65%" />

#### 1.3 静态链接

静态链接的主要步骤：

- 地址和空间分配：将目标文件的各段合并，并分配各个段的 **虚拟地址**
- 符号决议/绑定：计算每个符号(函数，全局变量等)的虚拟地址
- 重定位：进行符号解析，通过 .rel.data、.rel.text 等重定位表 修正指令中重定位入口的地址



### 2. 装载与动态链接

#### 2.1 装载

装载的方式：

- 覆盖载入：程序员手动管理各模块何时读入读出内存，现已不使用
- 页映射：操作系统使用虚拟内存管理内存页换入换出

操作系统角度装载可执行文件：

- 建立进程：创建独立的虚拟地址空间，建立可执行文件与虚拟地址的映射关系，设置 eip 寄存器运行程序
- 缺页错误：上述过程并未载入程序，当 CPU 执行时触发缺页错误，开始载入程序

ELF 文件的装载步骤：

- 检查格式
- 寻找 .interp 段，设置动态连接器路径
- 对 ELF 文件进行映射
- 初始化进程空间
- 返回 ELF 文件的入口点，设置 EIP 寄存器为该入口点，运行程序

#### 2.2 动态链接

引入动态链接的原因：原因一是使用静态链接时，每一个程序复制使用的库，造成内存和硬盘的浪费；原因二是公用库更新后，对于使用该库的程序都需要重新编译。

动态链接的思想：在 **程序运行时** 才链接形成一个完成程序

动态链接文件格式：.so(Linux)，.dll(Windows)

**动态链接步骤**：

- 启动动态链接器本身，动态链接器是静态链接且自举的
- 装载共享对象：合并可执行文件和链接器的符号到 **全局符号表**，将所依赖的共享对象的代码段和数据段映射到进程的地址空间
- 重定位和初始化

动态链接所使用的 ELF 段：

- .interp：存放动态链接器路径的字符串
- .dynamic：存放动态链接器所需要的信息